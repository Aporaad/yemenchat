# مقدمة---سأشرح المفاهيم الأربعة معماريًا، ثم أربطها ببعضها بشكل عملي:* `read()`* `watch()`* `Consumer`* `listener`علاقتهم بـ Provider# أولًا: ما هو الـ Listener؟## التعريف**Listener** هو:> دالة يتم تسجيلها ليتم استدعاؤها تلقائيًا عند حدوث تغيير.في Flutter، عند استخدام:```dartChangeNotifier```فهو يحتوي داخليًا على:```dartaddListener()removeListener()notifyListeners()```### ماذا يحدث فعليًا؟1. Widget يسجل نفسه كمستمع.2. عند استدعاء `notifyListeners()`3. يتم استدعاء جميع المستمعين.4. المستمع يقوم بإعادة build.---# علاقة Listener بـ ProviderProvider هو:> آلية لوضع كائن (Object) في أعلى شجرة الـ Widgets بحيث يمكن لأي Widget أسفلها الوصول إليه عبر context.> بمعنى آخر، هو Dependency Injection مبني فوق InheritedWidget.Provider يستخدم ChangeNotifier. عند كتابة:```dartChangeNotifierProvider(  create: (\\\\\\\\\\\\\\\_) => AuthController(),  child: MyApp(),)```يحدث:1. يتم إنشاء كائن واحد من AuthController2. يتم تخزينه داخل Widget خاص3. يتم إدراجه في شجرة الـ Widgets4. يصبح متاحًا عبر contextعند استدعاء `notifyListeners()`، كل Widget يستخدم `watch()` أو `Consumer` يتم إعادة بنائه تلقائيًا.---## كيف يتم تسجيل الـ listeners؟عندما تكتب في Widget:```dartcontext.watch<AuthController>()```أو:```dartConsumer<AuthController>(  builder: ...)```يحدث داخليًا:* يتم تسجيل هذا الـ Widget كمستمع (listener)* عند استدعاء `notifyListeners()` يتم إعادة بناء هذا الجزء فقط---# الفرق بين read و watch و Consumer---## 1️⃣ read()### ماذا يفعل؟```dartcontext.read<AuthController>()```* يحصل على الكائن.* لا يسجل listener.* لا يعيد البناء عند التغيير.### متى يستخدم؟* عند استدعاء دالة مثل login()* داخل `initState`* داخل `onPressed`### مثال:```dartElevatedButton(  onPressed: () {    context.read<AuthController>().login();  },)```لن يعيد بناء هذا الزر.---## 2️⃣ watch()### ماذا يفعل؟```dartcontext.watch<AuthController>()```* يحصل على الكائن.* يسجل listener.* يعيد build عند `notifyListeners()`.### متى يستخدم؟عندما تعتمد الواجهة على القيمة.### مثال:```dart@overrideWidget build(BuildContext context) {  final auth = context.watch<AuthController>();  return Text(auth.isLoggedIn ? "Welcome" : "Login");}```عند `login()` → سيتم إعادة بناء هذا Text.---## 3️⃣ Consumer### ماذا يفعل؟```dartConsumer<AuthController>(  builder: (context, auth, child) {    return Text(auth.isLoggedIn ? "Welcome" : "Login");  },)```* هو Widget منفصل يعيد بناء نفسه فقط عند التغيير.---## الفرق بين watch و Consumer|المقارنة|watch()|Consumer||-|-|-||مكان الاستخدام|داخل build|Widget مستقل||يعيد بناء|كامل build|الجزء داخل Consumer فقط||أداء أفضل؟|أقل|أفضل|---## مثال يوضح الفرق### باستخدام watch```dart@overrideWidget build(BuildContext context) {  final auth = context.watch<AuthController>();  return Column(    children: \\\\\\\\\\\\\\\[      Text(auth.isLoggedIn ? "Welcome" : "Login"),      HeavyWidget(),    ],  );}```عند التغيير:* Text يعاد بناؤه* HeavyWidget يعاد بناؤه أيضًا (حتى لو لم يعتمد على auth)### باستخدام Consumer```dartColumn(  children: \\\\\\\\\\\\\\\[    Consumer<AuthController>(      builder: (context, auth, child) {        return Text(auth.isLoggedIn ? "Welcome" : "Login");      },    ),    HeavyWidget(),  ],)```الآن:* فقط Text يعاد بناؤه* HeavyWidget لا يتأثر---# العلاقة معماريًا```ChangeNotifier      ↓notifyListeners()      ↓Provider      ↓Widgets المسجلة عبر:   watch()   Consumer```---# متى تستخدم كل واحد؟|الحالة|الأداة المناسبة||-|-||تريد تنفيذ دالة فقط|read()||تريد إعادة بناء الشاشة بالكامل|watch()||تريد إعادة بناء جزء محدد فقط|Consumer|---# الصورة الذهنية النهائية## read()"أعطني الكائن فقط"## watch()"أعطني الكائن وأخبرني إذا تغيّر"## Consumer"أعد بناء هذا الجزء فقط عندما يتغير"## listener"دالة تنتظر حدوث تغيير"---# الفرق المعماري العميق بين watch() و Consumerكلاهما:* يسجل **listener*** يعيد البناء عند `notifyListeners()`لكن الفرق في **نطاق إعادة البناء (Rebuild Scope)**.---## 1️⃣ watch() — يعتمد على موقع الاستدعاءعندما تكتب داخل `build()`:```dartfinal auth = context.watch<AuthController>();```* هذا الـ Widget بالكامل يصبح مستمعًا* أي `notifyListeners()` سيؤدي إلى إعادة تنفيذ build كامل### مثال```dartColumn(  children: \\\\\\\\\\\\\\\[    Text(auth.isLoggedIn ? "Welcome" : "Login"),    HeavyWidget(),    AnotherWidget(),  ],)```عند notifyListeners():* يتم إعادة بناء Text* يتم إعادة بناء HeavyWidget* يتم إعادة بناء AnotherWidgetحتى لو لم تعتمد هذه الـ Widgets على `auth`.---## 2️⃣ Consumer — يعزل نطاق إعادة البناء```dartColumn(  children: \\\\\\\\\\\\\\\[    Consumer<AuthController>(      builder: (context, auth, child) {        return Text(auth.isLoggedIn ? "Welcome" : "Login");      },    ),    HeavyWidget(),    AnotherWidget(),  ],)```الآن:* فقط الجزء داخل Consumer يعاد بناؤه* HeavyWidget و AnotherWidget لا يعاد بناؤهما---## الفرق المعماري الحقيقي|المقارنة|watch()|Consumer||-|-|-||يسجل listener|نعم|نعم||يعيد البناء|كامل الـ build|جزء محدد فقط||تحكم في الأداء|أقل|أعلى||أفضل في الشاشات المعقدة|لا|نعم|---## متى يكون الفرق مهم؟* الشاشة صغيرة → الفرق غير مهم* الشاشة كبيرة (مثل ChatScreen) → Consumer يمنع إعادة بناء عناصر ثقيلة مثل:  * ListView طويلة  * صور  * عناصر فيها حسابات---## مثال عملي في yemenchatلو استخدمت:```dartfinal auth = context.watch<AuthController>();```* كل مرة يتغير auth → سيتم إعادة بناء قائمة الرسائل بالكامل (غير مرغوب)الأفضل:```dartConsumer<AuthController>(  builder: (\\\\\\\\\\\\\\\_, auth, \\\\\\\\\\\\\\\_\\\\\\\\\\\\\\\_) {    return Text(auth.username);  },)```* فقط اسم المستخدم يعاد بناؤه---# لماذا watch() لا يعمل داخل initState()؟## التسلسل الحقيقي لإنشاء Widget```1) constructor2) createState3) initState4) didChangeDependencies5) build```## ماذا يفعل watch داخليًا؟`watch()` يعتمد على:```dependOnInheritedWidgetOfExactType()```* تربط الـ Widget بالـ InheritedWidget* تسجل dependency* تسمح بإعادة البناء لاحقًا⚠️ لا يمكن استخدامها إلا عندما يكون الـ Element مربوطًا بالكامل بالشجرة.---## المشكلة في initState()* الـ Widget لم ينتهِ من الارتباط بالشجرة* لا يمكن تسجيل dependency* Flutter يمنع استخدام watch هناك```dependOnInheritedWidgetOfExactType() called before build```---## لماذا read() يعمل داخل initState؟لأن `read()`:* لا يسجل dependency* لا يستدعي dependOnInheritedWidgetOfExactType بطريقة reactive* فقط يحصل على الكائن → آمن---## متى يمكن استخدام watch بأمان؟* داخل `build()`* داخل `didChangeDependencies()`* داخل Consumer---# ملخص معماري نهائي## watch()* يسجل dependency* يعيد بناء كامل الـ Widget* لا يعمل داخل initState## Consumer* يسجل dependency* يعزل إعادة البناء* أفضل للأداء## read()* لا يسجل dependency* لا يعيد البناء* يعمل في أي مكان---# لماذا هذا التصميم منطقي؟* Flutter يريد تسجيل dependencies أثناء build phase فقط* الحفاظ على استقرار شجرة الـ Elements* منع تسجيل listeners قبل اكتمال الربط---# خلاصة مركزة للعناصر|العنصر|دوره||-|-||ChangeNotifier|يدير قائمة listeners||notifyListeners|يخبرهم بوجود تغيير||Provider|يربط ChangeNotifier بالشجرة||watch()|يسجل Widget كمستمع||read()|لا يسجل مستمع||listener|دالة تنتظر حدوث تغيير|---# تدفق العملية عند login()```login()   ↓تغيير \\\\\\\\\\\\\\\_isLoggedIn   ↓notifyListeners()   ↓ChangeNotifier ينفذ جميع listeners   ↓Provider يخبر Flutter أن هناك تغيير   ↓Widgets التي تستخدم watch يتم إعادة build لها```---✅ بهذا الدمج أصبح كل النصين مترابطين، مع الحفاظ على ترتيب المفاهيم المعمارية، الأمثلة العملية، والجداول التوضيحية.