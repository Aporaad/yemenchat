11) نقاط يجب الانتباه لها إذا تريد “تحتـرفه” فعلاً

    الثيم: في main.dart مكتوب ThemeMode.light ثابت، يعني تبديل الثيم من الإعدادات لن ينعكس بالكامل حتى تربطه بـ settings.isDarkMode.

    ازدواجية رفع الصور: يوجد StorageService (Firebase Storage) لكن تدفق الدردشة الفعلي يستخدم Cloudinary عبر ImageUploadService. يحتاج قرار معماري موحد.

    README بسيط جدًا ولا يشرح إعداد Firebase فعليًا، فيحتاج توثيق أقوى عند الإنتاج.

=========================
MultiProvider 
ChangeNotifier


context.read<AuthController>();

يتيح هذا النمط طرق العرض للوصول إلى وحدات التحكم من خلال
 Provider.of<AuthController>(context) أو context.watch<AuthController>()، 
تشغيل إعادة البناء عندما تتغير حالة وحدة التحكم.
-------------

UI → Controller → Service → Firebase.

=========================
Firebase Cloud Messaging (FCM)
Messaging	firebase_messaging	Push notifications and FCM tokens

Notifications	flutter_local_notifications

services/notification_service.dart
 lib/main.dart
================
/controllers/contact_controller.dart,
 screens/contact_screen.dart


====================
Theme System
 lib/utils/constants.dart, lib/controllers/settings_controller.dart

=========================


=========================

=========================
ب) ثغرات/ملاحظات مهمة في “الوثوقية” (حسب الكود الحالي)

    لا يوجد Route Guard مركزي يمنع الوصول لشاشات داخلية إذا لم يكن المستخدم مسجّل (التوجيه يعتمد أساسًا على Splash فقط).

    Remember me موجود كـ UI فقط وغير موصول بمنطق فعلي (لا تخزين/استعادة مخصصة).

    Session Duration موجود في الإعدادات لكنه غير مطبق فعليًا على الجلسة (مجرد قيمة محفوظة).

    loadSettings() في SettingsController موجود، لكن لا يظهر استدعاؤه عند الإقلاع، فالإعدادات قد لا تُحمّل تلقائيًا عند بدء التطبيق.

    تسجيل الجهاز في security logs حاليا ثابت كنص 'Flutter App' وليس بصمة جهاز/عنوان IP فعلي.

ملاحظة صغيرة مفيدة

خيار Remember me موجود في واجهة الدخول لكنه حاليًا لا يغيّر سلوك المصادقة فعليًا (متغير UI فقط).


=========================



Accessing Controllers in Views

Views access controllers using Provider's context-based lookup:

// Method 1: Using Consumer for granular rebuilds
Consumer<AuthController>(
  builder: (context, auth, child) {
    if (auth.isLoading) {
      return CircularProgressIndicator();
    }
    return Text('Welcome, ${auth.currentUser?.fullName ?? "Guest"}');
  },
)
 
// Method 2: Using context.watch for simplicity
final auth = context.watch<AuthController>();
if (auth.isLoggedIn) {
  // Show logged-in UI
}
 
// Method 3: Using Provider.of for non-reactive access
final auth = Provider.of<AuthController>(context, listen: false);
await auth.signOut();



====================================
class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final settingsController = context.watch<SettingsController>();
-----------------
onPressed: () {
  final authController = Provider.of<AuthController>(context, listen: false);
  authController.signOut();
}


--------------
The architecture organizes code into four distinct layers, each with specific responsibilities and clear dependency rules. Controllers depend on services abstractions, services depend on models, and the presentation layer depends on controllers for state management.


تنظم الهندسة المعمارية التعليمات البرمجية في أربع طبقات متميزة ، لكل منها مسؤوليات محددة وقواعد اعتماد واضحة. تعتمد وحدات التحكم على تجريد الخدمات ، وتعتمد الخدمات على النماذج ، وتعتمد طبقة العرض التقديمي على وحدات التحكم لإدارة الدولة.